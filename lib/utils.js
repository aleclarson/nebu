// Generated by CoffeeScript 2.3.0
var matchType, u;

u = exports;

matchType = function(type) {
  return function(node) {
    return node.type === type;
  };
};

u.noop = function() {};

// Find a matching node. Check the given node first.
u.lookup = function(node, match) {
  if (typeof match === 'string') {
    match = matchType(match);
  }
  while (node) {
    if (match(node)) {
      return node;
    }
    node = node.parent;
  }
  return null;
};

// Find a matching parent.
u.findParent = function(node, match) {
  if (typeof match === 'string') {
    match = matchType(match);
  }
  while (node = node.parent) {
    if (match(node)) {
      return node;
    }
  }
  return null;
};

// Is the given node first on its starting line?
u.isFirst = function(node, input) {
  var lineStart;
  lineStart = 1 + input.lastIndexOf('\n', node.start);
  return /^[ \t]*$/.test(input.slice(lineStart, node.start));
};

// Compute tab count of a block.
u.parseDepth = function(node, tab, input) {
  var lineEnd, lineStart, prefix;
  lineStart = 1 + input.lastIndexOf('\n', node.start);
  lineEnd = input.indexOf('\n', lineStart);
  if (lineEnd === -1) {
    lineEnd = input.length;
  }
  prefix = /^[ \t]*/.exec(input.slice(lineStart, lineEnd))[0];
  return prefix.length / tab.length;
};

// Increment the indentation level.
u.indent = function(code, tab, depth = 1) {
  var indent, prev, re, width;
  indent = tab.repeat(depth);
  // Avoid extra work if using same tab string (or none).
  prev = u.guessTab(code);
  if (!prev || prev === tab) {
    if (!indent) {
      return code;
    }
    return code.replace(/\n/g, '\n' + indent);
  }
  // Fix the existing indentation.
  re = new RegExp(`\n((?:${prev})*)`, 'g');
  width = prev.length;
  return code.replace(re, function(_, prev) {
    return '\n' + indent + tab.repeat(prev.length / width);
  });
};

// Reset the indentation level to zero.
// Assume the first line is never indented.
// This is useful when moving/duplicating code.
u.stripIndent = function(code, tab) {
  var depth, k, len1, line, re, ref, width;
  re = new RegExp(`^((?:${tab})*)`);
  width = tab.length;
  depth = 0;
  ref = code.split('\n');
  // Find the first indentation level that isn't zero.
  for (k = 0, len1 = ref.length; k < len1; k++) {
    line = ref[k];
    depth = re.exec(line)[1].length / width;
    if (depth !== 0) {
      break;
    }
  }
  if (depth > 1) {
    re = new RegExp(`\n((?:${tab})*)`, 'g');
    return code.replace(re, function(_, prev) {
      return '\n' + tab.repeat(Math.max(0, 1 + (prev.length / width) - depth));
    });
  } else {
    return code;
  }
};

// Adapted from magic-string (https://goo.gl/pHi5kK)
u.guessTab = function(code) {
  var lines, spaced, tabbed;
  lines = code.split('\n');
  tabbed = lines.filter(function(line) {
    return /^\t+/.test(line);
  });
  spaced = lines.filter(function(line) {
    return /^ {2,}/.test(line);
  });
  if (!tabbed.length && !spaced.length) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return '\t';
  }
  // Guess the number of spaces per tab.
  return ' '.repeat(spaced.reduce(function(prev, cur) {
    return Math.min(prev, /^ +/.exec(cur)[0].length);
  }, 2e308));
};

// The node assumes ownership of its starting line, unless other nodes exist on
// the same line. It also assumes ownership of the first trailing semicolon or
// comma. Works with comma-delimited expressions, too.
u.greedyRange = function(input, node, i) {
  var end, j, len, lineEnd, lineStart, sib, sibAfter, sibBefore, sibs, start;
  // Our minimum range.
  ({start, end} = node);
  // The trailing newline (or end of input).
  lineEnd = input.indexOf('\n', end);
  if (lineEnd === -1) {
    lineEnd = input.length;
  }
  // Be sibling-aware.
  sibs = node.parent[node.ref];
  if (!Array.isArray(sibs)) {
    sibs = null;
  } else {
    if (i == null) {
      i = sibs.indexOf(node);
    }
    len = sibs.length;
    if (i !== len - 1) {
      // Find a sibling after us that isn't stale yet.
      j = i;
      while (++j !== len) {
        sib = sibs[j];
        if (!sib.stale) {
          sibAfter = sib;
          break;
        }
      }
      if (sibAfter) {
        // Take ownership until the start of the sibling after us
        // if it exists on the same line that we end on.
        if (sib.start < lineEnd) {
          end = sib.start;
          return [start, end];
        }
      }
    }
  }
  // The leading newline.
  lineStart = 1 + input.lastIndexOf('\n', start);
  // Avoid extra work if we are the first node on our starting line.
  if (start === lineStart) {
    start = lineStart - 1;
  } else {
    // Find a sibling before us that isn't stale yet.
    if (sibs) {
      while (--i !== -1) {
        sib = sibs[i];
        if (!sib.stale) {
          sibBefore = sib;
          break;
        }
        if (sib.end < lineStart) {
          // Avoid checking every sibling.
          break;
        }
      }
    }
    // Take ownership of leading whitespace if the sibling before us ends on the
    // line we start on. We'll never take ownership of both leading and trailing
    // whitespace in the same removal, unless no siblings exist on our line(s).
    if (sibBefore) {
      start = Math.max(sib.end, lineStart - 1);
    // Take ownership of the leading newline if our parent doesn't start on it.
    } else if (node.parent.start < lineStart) {
      start = lineStart - 1;
    }
  }
  // Avoid extra work if we are the last node on our ending line.
  if (end !== lineEnd) {
    if (!sibAfter) {
      // Take ownership until the trailing newline
      // if our parent doesn't end on it.
      if (node.parent.end > lineEnd) {
        end = lineEnd;
      }
    } else if (!sibBefore || start > sibBefore.end) {
      end = Math.min(sibAfter.start, lineEnd);
    }
  }
  return [start, end];
};
